---
title: 高并发大流量解决方案 8  数据库缓存层优化
date: 2018-02-15 16:34:29
tags: 高并发
---

### 数据库缓存层优化

#### 1. 什么是数据库缓存

MySQL 等一些常见的关系型数据库的数据都存储在磁盘当中，在高并发场景下，业务应用对 MySQL 产生的增删改查操作造成巨大的 I/O 开销和查询压力，这无疑对数据库和服务器都是一种巨大的压力，为了解决此类问题，缓存数据的概念应运而生。

<!-- more -->

优势：

- 极大地解决数据库服务器的压力
- 提高应用数据的响应速度

常见的缓存形式：<b style="color:red;">内存缓存（尽量使用）</b>、文件缓存

#### 2. 为什么要使用数据库缓存

缓存数据是为了让客户端很少甚至不访问数据库服务器进行数据的查询，高并发下，能最大程度地降低对数据库服务器的访问压力。

> 流程

用户请求 -- 数据查询 -- 连接数据库服务器并查询数据 -- 将数据缓存起来（HTML、<b style='color:red'>内存</b>、json、序列化） -- 显示给客户端

用户再次请求或新用户访问 -- 数据查询 -- 直接从缓存中获取数据 -- 显示给客户端

缓存需要考虑的问题

- 缓存方式的选择：尽量使用内存
- 缓存场景的选择：哪些数据适合使用缓存，如不经常修改的数据
- 缓存数据的实时性，不建议同步地修改
- 缓存数据的稳定性 

#### 3. 使用 MySQL 查询缓存

##### 1. 启用 MySQL 查询缓存

可极大降低 CPU 使用率

> 开启方法：

`query_cache_type`: 查询缓存类型，有 0，1，2 三个值。0 表示不使用查询缓存；1 表示始终使用查询缓存；2 表示按需使用查询缓存。

`query_cache_type=1` 时，也可以在查询语句中关闭查询缓存
```
SELECT SQL_NO_CACHE * FROM my_table WHERE condition;
```

`query_cache_type=2` 时，可按需使用查询缓存

```
SELECT SQL_CACHE * FROM my_table WHERE condition;
```

query_cache_size: 默认情况下，值为0，表示为查询缓存预留的内存为 0，则无法使用查询缓存。

```
SET GLOBAL query_cache_size = 134217728; (128M)
```

查询缓存可以看做是 SQL 文本和查询结果的映射，第二次查询的 SQL 和第一次查询的 SQL 完全相同（多一个空格都不行），则会使用缓存

```
SHOW STATUS LIKE 'Qcache_hits'; // 查看命中次数
```

表的结构或数据发送改变时，查询缓存中的数据不再有效（即时失效），如果数据表的写入或修改频率比较高，查询缓存就失去意义了。

> 清理缓存

```
FLUSH QUERY CACHE; // 清理查询缓存内存碎片
RESET QUERY CACHE; // 从查询缓存中移除所有查询
FLUSH TABLES; // 关闭所有打开的表，同时该操作将会清空查询缓存中的内容
```

#### 4. 使用 memcache 缓存

对于大型站点，如果没有中间缓存层，当流量打入数据库层时，即便之前的几层为我们挡住一部分流量，但是在大并发的情况下，还是会有大量请求涌入数据库层，这样对于数据库服务器的压力冲击很大，响应速度也会下降，因此添加中间缓存层很有必要。

memcache 是一套分布式的高速缓存系统，目前被许多网站使用以提升网站的访问速度，尤其对于一些大型的、需要频繁访问数据库的网站访问速度提升效果十分显著。

memcache 是一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的 hash 表，它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。简单说就是将数据调用到内存，然后从内存中读取，从而大大提高读取速度。

> 工作流程：

先检查客户端的请求数据是否在 memcached 中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在 memcached 中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到 memcached 中。

> 常用方法：

- 获取：get(key)
- 设置：set(key, val, expire)
- 删除：delete(key)

> 通用缓存机制：

用查询的方法名 + 参数作为查询时的 key value 对应的 key 值。

#### 5. 使用 Redis 缓存

与 memcache 的区别

- 性能相差不大
- Redis 在 2.0 版本后增加了自己的 VM 特性，突破物理内存的限制，memcache 可以修改最大可用内存，采用 LRU（Least recently used，最近最少使用）算法
- Redis 依赖客户端来实现分布式读写
- memcache 本身没有数据冗余机制，Redis 支持（快照、AOF），依赖快照进行持久化，AOF 增强了可靠性的同时，对性能有所影响。
- memcache 不支持持久化，通常做缓存，提升性能；
- memcache 在并发场景下，用 cas 保证一致性，Redis 事务支持比较弱，只能保证事务中的每个操作连续执行。
- Redis 支持多种类型的数据类型
- Redis 常用于数据量较小的高性能操作和运算上
- memcache 用于在动态系统中减少数据库负载，提升性能；适合做缓存，提升性能


#### 6. 其他数据缓存

Session：尽量存到 memcache 或 Redis 里
