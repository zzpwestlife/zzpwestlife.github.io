---
title: 高并发大流量解决方案 3 浏览器缓存和压缩优化技术
date: 2018-02-15 16:31:49
tags: 高并发
---

### 1. http 缓存机制

http 缓存模型中，如果请求成功会有三种情况
- `200 from cache`：直接从本地缓存中获取响应，最快速、最省流量，因为根本没有向服务器发送请求；
- `304 not modified`：协商缓存，浏览器在本地没有命中的情况下，请求头中发送一定的校验数据到服务器，如果服务端数据没有改变，浏览器从本地缓存响应，返回 304，即先去服务端验证文件是否被修改过。这种方式快速，发送的数据很少，只返回一些基本的响应头信息，数据量很小，不发送实际响应体。
- `200 ok`：以上两种缓存全部失败，服务器返回完整响应，没有用到缓存，相对最慢。

<!-- more -->

#### 1. 本地缓存

浏览器认为本地缓存可以使用，不会去请求服务端。

相关 `Header`
1. `Pragma`：HTTP1.0 时代的遗留产物，该字段被设置为 `no-cache` 时，会告知浏览器禁用本地缓存，即每次都向服务器发送请求。
2. `Expires`：HTTP1.0 时代用来启用本地缓存的字段，标记缓存的过期时间。`Expires` 对应一个格林威治时间，告知浏览器缓存过期的时刻，如果还没到期，表名缓存有效，无需请求服务器。问题：服务端的时间和客户端的时间基准不一定一致，如果时间差距大，会影响缓存效果。
3. `Cache-Control`：HTTP1.1 针对 `Expires` 时间基准不一致的问题的解决方案。该参数告知浏览器缓存过期的时间间隔（秒数）而不是时刻，即使具体时间不一致，也不影响缓存的效果。设置为 `no-store`，则禁止浏览器缓存响应；`no-cache`，不允许直接使用本地缓存，先发起请求和服务器协商；`max-age=3600`，告知浏览器本地缓存有效的最长期限，单位为秒。

> <span style="color:red">优先级： `Pragma` > `Cache-Control` > `Expires`</sapn>


#### 2. 协商缓存

  当浏览器没有命中本地缓存，如本地缓存过期或者响应中声明不允许直接使用本地缓存，那么浏览器肯定会发起服务端请求。
  
  服务端会验证数据是否被修改，如果没有，通知浏览器使用本地缓存。
  
  相关 `Header`
  1. `Last-Modified`：资源的最后修改时间，浏览器请求一个资源的时候，服务端进行响应，并带一个 `Last-Modified`，下次再请求服务器的时候，带着这个时间（header 中添加 `If-Modified-Since`），服务器会判断这个时间点之后，该资源是否发生了修改，如果没有修改，会返回304，告知浏览器使用本地缓存；
1. `ETag`：HTTP1.1 推出，文件的指纹标识符，第二次浏览器请求服务的时候，带着这个指纹（header 中添加 `If-None-Match`），如果文件内容修改，指纹会改变。

#### 3. 缓存策略的选择

##### 1. 适合缓存的内容

- 不变的图片、logo 等；
- js、css 静态文件；
- 可下载的内容、媒体文件等；

##### 2. 建议使用协商缓存的内容

经常改变的文件适合使用协商缓存，如 
- html 文件；
- 经常替换的图片；
- 经常修改的 js、css 文件。

js、css 文件的加载可以加入文件的签名来拒绝缓存，如时间戳、版本号等。index.css?签名

##### 3. 不建议缓存的内容

- 用户隐私等敏感数据；
- 经常改变的API数据接口。

### 2. nginx 配置缓存策略

简单示例

``` php
<?php
$since = isset($_SERVER['HTTP_IF_MODIFIED_SINCE']) ? $_SERVER['HTTP_IF_MODIFIED_SINCE'] : '';
// 模拟文件修改
$lifetime = 3600;
if (!empty($since)) {
	if (strtotime($since) + $lifetime > time()) {
		header('HTTP/1.1 304 Not Modified');
		exit;
	}
}

header(sprintf('Last-Modified: %s GMT'), gmdate('D, d M Y H:i:s', time()));
echo time();
```

#### 1. 本地缓存配置

`add_header` 指令：添加状态码为2XX和3XX的响应头信息。

语法： `add_header name value [always];` name 可以为`pragma`/`cache-control`/`expires`，可以继承。<span style="color:red">expires 最常用</span>，通知浏览器过期时长，后面跟数字和单位，如 `expires 30d;`，数值为负相当于 `cache-control no-cache;`，数值为0或正值相当于 `cache-control max-age=指定时间;`。

nginx 配置实例
``` nginx
location ~ .*\.(gif|jpg|png|flv|swf|rar|zip)$
{
	expires 30d;
}

location ~ .*\.(js|css)?$
{
	expires 12h;
}
```

#### 2. 协商缓存配置

etag指令，指定签名。

etag on | off， 默认为 on


### 3. 前端代码和资源的压缩

优势：让资源文件更小，加快文件在网络中的传输，让网页更快地展示，降低带宽和流量开销。

压缩方式：js、css、图片、HTML文件压缩；gzip 压缩

#### 1. js 代码的压缩

一般是去掉多余的空格和回车、替换长变量名、简化一些代码写法等。

常用压缩工具：UglifyJS、YUI Compressor、Closure Compiler

在线工具： https://tool.css-js.com/  或 https://www.css-js.com/

#### 2. css 代码压缩

原理与 js 压缩类似

常用压缩工具：YUI Compressor、css Compressor

#### 3. HTML 代码压缩

不建议使用代码压缩，有时会破坏代码结构，可以使用 gzip 压缩，也可以使用 htmlcompressor 工具，但转换后一定要检查代码结构。

在线工具： http://htmlcompressor.com/compressor/

#### 4. 图片压缩

压缩工具： [tinypng](https://tinypng.com/)、[JpegMini](http://www.jpegmini.com/)、[ImageOptim](https://www.imageoptim.com)

#### 5. <span style="color:red;">gzip 压缩</span>

``` nginx
gzip on | off;
gzip_buffers 32 4K | 16 8K; # 缓冲，在内存中缓冲几块，每块多大
gzip_comp_level [1-9]; 推荐6，压缩级别，级别越高，压得越小，越浪费CPU资源
gzip_disable # 正则匹配UA，什么样的uri不进行gzip
gzip_min_length 200 # 开始压缩的最小长度
gzip_http_version 1.0 | 1.1 # 开始压缩的http版本
gzip_proxied # 设置请求的代理服务器
gzip_types text/plain application/xml # 对哪些类型的文件启用压缩
gzip_vary on | off # 是否传输gzip压缩标记
```

#### 6. 其他工具

自动化构建工具 Grunt 等。
