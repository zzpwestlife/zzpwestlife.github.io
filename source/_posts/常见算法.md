---
title: 常见算法
date: 2018-02-16 19:36:39
tags: 算法
---

> 写出常见的排序算法，并用 PHP 实现冒泡排序，将数组按照从小到大的方式进行排序

<!--more-->

考点：
- 冒泡排序的原理和实现
- 延伸：算法的概念
- 延伸：时间复杂度和空间复杂度的概念
- 延伸：常见排序算法
- 延伸：常见查找算法

### 1. 算法概念
解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作

一个问题可以有多种算法，每种算法都有不同的效率

一个算法具有 5 个特性：有穷性（算法能计算完，不能是死循环）、确切性（每一步都要有意义）、输入项、输出项、可行性（可以执行，每一步都是正确的）。

### 2. 算法评定
算法分析的目的在于选择合适的算法和改进算法

一个算法的评价主要是从时间复杂度和空间复杂度来考虑

#### 1. 时间复杂度
执行算法所需要的计算工作量，也就是时间消耗的效率。一般来说，计算机算法是问题规模 $$n$$ 的函数 $$f(n)$$，算法的时间复杂度也一次记作 $$T(n)=O(f(n))$$

问题的规模 $$n$$ 越大，算法执行的时间的增长率与 $$f(n)$$ 的增长率正相关，称作渐进时间复杂度。

##### 计算方式
1. 得出算法的计算次数公式
2. 用常数 $$1$$ 来取代所有时间中的所有加法常数，如 $$O(3)$$ 要写成 $$O(1)$$
3. 在修改后的运行次数函数中，只保留最高阶项，如 $$O(n^2+n+1)$$ 要写成 $$O(n^2)$$
4. 如果最高阶存在且不是1，则去除与这个项相乘的常数，如 $$O(3n)$$ 要写成 $$O(n)$$


##### 举例

1. 常数阶：$$O(1)$$
``` php
<?php
$n = 3;
echo $n;
echo $n;
echo $n;
```

2. 线性阶：$$O(n)$$
``` php
<?php
$n = 100;
$sum = 0;
for ($i = 0; $i < $n; ++$i) {
	$sum += $n;
}
echo $sum;
```

3. 平（立）方阶：$$O(n^2)/O(n^3)$$
``` php
<?php
$n = 100;
$sum = 0;
for ($i = 0; $i < $n; ++$i) {
	for ($j = 0; $j < $n; ++$j) {
		$sum += $j;
	}
}
echo $sum;
```

4. 对数阶：$$O(log_2n)$$

``` php
<?php
$n = 1000;
while ($n >= 1) {
	$n = $n/2;
}
```

效率对比
$$$
O(1) > O(log_2n) > O(n) > O(nlog_2n) > O(n^2) > O(n^3) > O(2^n) > O(n!) > O(n^n)
$$$

最坏情况，如果没有特别说明，时间复杂度就是指最坏情况下的时间复杂度


#### 2. 空间复杂度

算法需要消耗的内存空间，记作 $$S(n)=O(f(n))$$

包括程序代码所占用的空间，输入数据所占用的空间和辅助变量所占用的空间三部分

计算和表示方法与时间复杂度类似，一般用复杂度的渐进性来表示

有时用空间换取时间

冒泡排序的元素交换，空间复杂度$$O(1)$$

排序算法：冒泡排序、直接插入排序、希尔排序、选择排序、快速排序、堆排序、归并排序

### 3. 排序算法

#### 1. 冒泡排序
原理：两两相邻的数进行比较，如果反序就交换，否则不交换

时间复杂度：最坏 $$O(n^2)$$，平均 $$O(n^2)$$

空间复杂度：$$O(1)$$

对于一个长度为 N 的数组，我们需要排序 N-1 轮，每 i 轮 要比较 N-i 次。对此我们可以用双重循环语句，外层循环控制循环轮次，内层循环控制每轮的比较次数。

``` php
<?php 
function order($arr) {
  　　$count = count($arr);
  　　$temp = 0; 
 　　 // 外层控制排序轮次
  　　for ($i = 0; $i < $count - 1; $i++) {
      　　// 内层控制每轮比较次数
      　　for ($j = 0; $j < $count - 1- $i; $j++){
            　　if ($arr[$j] > $arr[$j + 1]) {
                　　$temp = $arr[$j];
                　　$arr[$j] = $arr[$j + 1];
                　　$arr[$j + 1] = $temp;
           　　}
     　　 }
  　　} 
    return $arr;
   }     


 $arr= array(6, 3, 8, 2, 9, 1);
$res =  order($arr);
var_dump($res);
```

#### 2. 直接插入排序

原理：每次从无序表中取出第一个元素，把它出入到有序表的合适位置，使有序表仍然有序

时间复杂度：最坏 $$O(n^2)$$，平均 $$O(n^2)$$

空间复杂度：$$O(1)$$

#### 3. 希尔排序（shell sort）
希尔排序是基于插入排序的，区别在于插入排序是相邻的一个个比较（类似于希尔中 h=1 的情形），而希尔排序是距离 h 的比较和替换。

希尔排序中一个常数因子 n，原数组被分成各个小组，每个小组由 h 个元素组成，很可能会有多余的元素。当然每次循环的时候，h 也是递减的（h=h/n）。第一次循环就是从下标为 h 开始。希尔排序的一个思想就是，分成小组去排序。

时间复杂度：最坏 $$O(n^2)$$，平均 $$O(n*log_2n)$$

空间复杂度：$$O(1)$$

#### 4. 选择排序

原理：每次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完

时间复杂度：最坏 $$O(n^2)$$，平均 $$O(n^2)$$

空间复杂度：$$O(1)$$

#### 5. 快速排序

原理：找到当前数组中的任意一个元素（一般选择第一个元素），作为标准，新建两个空数组，遍历整个数组元素，
如果遍历到的元素比当前的元素要小，那么就放到左边的数组，否则放到右面的数组，然后再对新数组进行同样的操作，
不难发现，这里符合递归的原理，所以我们可以用递归来实现。
使用递归，则需要找到递归点和递归出口：
递归点：如果数组的元素大于 1，就需要再进行分解，所以我们的递归点就是新构造的数组元素个数大于 1
递归出口：我们什么时候不需要再对新数组不进行排序了呢？就是当数组元素个数变成 1 的时候，所以这就是我们的出口。

时间复杂度：最坏 $$O(n^2)$$，平均 $$O(nlog_2n)$$

空间复杂度：最坏 $$O(n)$$，平均 $$O(log_2n)$$

#### 6 .堆排序

二叉树。。。

时间复杂度：最坏 $$O(nlog_2n)$$，平均 $$O(nlog_2n)$$

空间复杂度：$$O(1)$$

#### 7. 归并排序
就是利用归并（合并）的思想实现的排序方法。它的原理是假设初始序列含有 n 个元素，则可以看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 ⌈ n / 2⌉ （⌈ x ⌉ 表示不小于 x 的最小整数）个长度为 2 或 1 的有序序列；再两两归并，······，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法就成为 2 路归并排序。


时间复杂度：最坏 $$O(nlog_2n)$$，平均 $$O(nlog_2n)$$

空间复杂度：$$O(n)$$

#### 8. 总结

快速排序、归并排序的理想时间复杂度都是 $$O(nlog_2n)$$，但是快速排序的时间复杂度并不稳定，最坏情况下复杂度为 $$O(n^2)$$，所以最理想的算法还是归并排序。


### 4. 查找方法

#### 1. 二分查找

原理：从数组的中间元素开始，如果中间元素正好是要查找的元素，搜索结束，如果某一个特定的元素大于有这小鱼中间元素，则在数组大于或者小于中间元素的那一半中查找，而且跟开始一样从中间开始比较，如果某一步骤数组为空，表示找不到。

时间复杂度：最坏 $$O(log_2n)$$，平均 $$O(log_2n)$$

空间复杂度：迭代 $$O(1)$$，递归 $$O(log_2n)$$

#### 2. 顺序查找

原理：按一定的顺序检查数组中的每一个元素，直到找到所要寻找的特定值为止。

时间复杂度：最差 $$O(n)$$，平均 $$O(n)$$

空间复杂度：$$O(1)$$

#### 3. 总结

二分查找算法的时间复杂度最差是 $$O(log_2n)$$，顺序查找的时间复杂度最差为 $$O(n)$$，所以二分查找更快，但是递归条件下，二分查找更消耗内存。


### 5. 解题方法

需要充分理解各种排序算法和查找算法的原理以及实现方式，另外还需要理解时间复杂度和空间复杂度的计算方式和概念，考察的是逻辑思维能力，需要仔细研究各种算法的实现方式。


### 6. 真题

#### 1. 简述时间复杂度和空间复杂度的概念

#### 2. 对无序数组排序，最优的时间复杂度是什么，用 PHP 或者 JavaScript 写出一个实际的例子，该算法的空间复杂度是多少？

快速或归并

#### 3. 一个有序数组中，查询特定 item 是否存在的最优算法是什么？时间复杂度多少？